---
title: "Product Reverse Engineering"
output:
  html_document: default
  word_document: default
---

The analysed product (according to  description) targets investors who are willing semi-actively manage their portfolios and are interested in tax reliefs due its classification as a life insurance product (saving for retirement). 

We are interested in expected return of the product if the investor is having a long investment horizon and how it compares to investing into similar financial instruments directly.

Underlying asset performance and portfolio optimisation calculations will be done using functions from *PortfolioAnalytics* package. Data observations will be collected on the fly:

```{r}
# Used packages
suppressMessages(suppressWarnings(library(readxl)))
suppressMessages(suppressWarnings(library(ggplot2)))
suppressMessages(suppressWarnings(library(PortfolioAnalytics)))

# Initiate the analysis sequence for gathering observations
source('../strfa.R')
fp <- analysis('Product Reverse Engineering', datarefl='fpo')
```

# Composition
The product allows to combine a selection of fund shares (positions) into a portfolio:

```{r}
# Observed that the product is comprised of positions in funds
add_obs(fp, list(object=c('PRODUCT', 'POSITION', 'POSITION>units', 'FUND'),
  property=rep('mbrp', 4), value=rep('product', 4)))

add_obs(fp, list('PRODUCT|contract_number>POSITION', 'type', 'defined'))
add_obs(fp, list('FUND|id>POSITION', 'type', 'defined'))

# Load the table which lists funds available for the product
FUND <- read_excel('../data/fp.xlsx', sheet='funds')
str(FUND, strict.width='cut', width=70)

# Observations about fund table
add_obs(fp, cbind(object=paste0('FUND>', names(FUND)),
  property=rep('mbrp', ncol(FUND)), value=rep('product', ncol(FUND))))

# Visualise the product structure
fp <- grow(fp, 'POSITION', attrs=TRUE)
fp
```

# Performance
Annualised returns are suitable performance measurements for this kind of product and long investment horizon. Historical net asset values are basis for performance calculations. Default performance as return of the portfolio comprised of all equally weighted assets:

```{r fig.height=8, fig.width=12}
# Load fund value change data
NAV <- as.data.frame(read_excel('../data/fp.xlsx', sheet='prices'))

# Present as extended time series object for performance calculation functions
nw <- reshape(NAV[ ,1:3], direction='wide', idvar=c('date'), timevar='ticker')
NAV_wide <- xts(nw[, -1], order.by=as.Date(nw[ ,1], '%d.%m.%Y'))
names(NAV_wide) <- gsub('nav.', '', names(NAV_wide))

# Populate NA with previous value
NAV_wide <- na.locf(NAV_wide)

# Add historical prices to structure
add_obs(fp, list('NAV', 'mbrp', 'performance'))
add_obs(fp, list('FUND|id>NAV', 'type', 'defined'))
add_obs(fp, cbind(object=paste0('NAV>', names(NAV)),
  property=rep('mbrp', ncol(NAV)), value=rep('performance', ncol(NAV))))

# Daily returns
fp_ret <- Return.calculate(NAV_wide)

# Annualised returns of years with sufficient data
ass_ret_ann <- function(x) {
  ifelse(sum(!is.na(x)) > 300, Return.annualized(x, scale=length(x)), NA)
}

fp_ret <- lapply(fp_ret, period.apply, endpoints(fp_ret, 'years'), ass_ret_ann)
fp_ret <- do.call(merge, fp_ret)

# Exclude assets and years with insufficient performance data
drops <- colnames(fp_ret['2007',is.na(fp_ret['2007'])])
FUND[FUND$ticker %in% drops, c('isin', 'name', 'ccy', 'ticker')]

fp_ret <- fp_ret[ ,!(names(fp_ret) %in% drops)]
fp_ret <- fp_ret[complete.cases(fp_ret), ]

# Annualised returns of funds in descending order 
ass_ret <- colMeans(fp_ret)
ass_ret <- ass_ret[order(ass_ret, decreasing=TRUE)] 
round(ass_ret, 4)

# Annualised standard deviations of equally weighted portfolio
ass_sd <- StdDev(fp_ret)[1, ]
ass_sd <- ass_sd[names(ass_ret)]
round(ass_sd, 4)

# Equally weighted portfolio mean historical return
hist_ret <- mean(ass_ret)
round(hist_ret, 4)

# Risk and return scatter plot
chart.RiskReturnScatter(cbind(ass_ret, ass_sd), method='nocalc', add.sharpe=NA)

# Stucture with attributes for performance analysis and default return
add_obs(fp, list('FUND>return', 'mbrp', 'performance'))
add_obs(fp, list('FUND>risk', 'mbrp', 'performance'))
add_obs(fp, list('PRODUCT>return', 'mbrp', 'performance'))
add_obs(fp, list('PRODUCT>return', 'value', round(hist_ret, 4)))

# Separate product and perfomance calculation parts
fp <- applyPartitioning2(fp, partitioning='mbrp')
fp <- grow(fp, 'FUND', depth=2, attrs=TRUE, vals=TRUE)
fp
```

*TODO: Portfolio variance should be calculated as well?*

# Transactions
From customer statements 9 types of possible transaction types were identified. Transactions affect positions and can be initiated either by the bank or the customer. We will skip analyses of some transaction types: inital conclusion fee, obsolete insurance risk premiums, possible dividend payments, and effect of widthrawals. Instead, we concentrate on more specific product management fee and purchase price margin analyses:

```{r fig.height=8, fig.width=12}
# Annualised returns corrected by asset management fee
# amfees <- FUND[match(names(fp_ret), FUND$ticker), 'amfee']/100
# amfees[is.na(amfees)] <- 0

# fp_ret_corr <- fp_ret - amfees
# ass_ret_corr <- colMeans(fp_ret_corr)
#ass_ret_corr <- ass_ret_corr[order(-ass_ret_corr)]

# Product management fee deduction
ass_ret_corr <- mean(ass_ret - mean(c(0.5, 0.75, 1, 1.25))/100)
round(ass_ret_corr, 4)

# Transaction entiry with attributes
txn <- paste0('TRANSACTION', c('', '>date', '>type', '>units'))
add_obs(fp, list(object=txn, property=rep('mbrp', 4), value=rep('product', 4)))

# add_obs(fp, list('FUND|id>TRANSACTION', 'type', 'defined'))
add_obs(fp, list('POSITION|id>TRANSACTION', 'type', 'defined'))

fp <- grow(fp, 'TRANSACTION', attrs=TRUE)
fp
```

Conclusions on analysed transactions and how these compare to direct purchasing of funds

# Forecasting
```{r fig.height=8, fig.width=12}
add_obs(fp, list('PRODUCT>date', 'mbrp', 'performance'))
add_obs(fp, list('PRODUCT>risk', 'mbrp', 'performance'))
add_obs(fp, list('POSITION>weight', 'mbrp', 'performance'))

fp <- grow(fp, 'POSITION', attrs=TRUE, vals=TRUE)
fp
```


# Conclusions
```{r fig.height=10, fig.width=14}
tn <- c('composisition', 'performance', 'transactions', 'forecasting')
signoff(fp, thumb_seq=c(2, 4, 5, 6), thumb_narr=tn)
```

# Discussion
NaÃ¯ve analysis: Risk management

Price history does not cover same periods, especially 2008/2009 financial crises

*TODO: Would be nice to choose between partitioning2 colours*
```{r eval=FALSE}
# Optimised Product

*TODO: Different currencies? Regions? Bonds vs stocks vs commodities?*

*TODO: Checkpoint Performance as well?*

*TODO: Sizing utilised to visualise value?*

# Stucture with attributes optimised performance

fp <- grow(fp, 'POSITION', attrs=TRUE, vals=TRUE)
fp

fig.height=20
autoplot(fp_ret)

arc3 <- fp_ret[ ,c("XMWO", "TEMTACU", "PIMGIIA")]
FUND[FUND$ticker %in% colnames(arc3), c('ticker', 'name', 'ccy', 'sharpe', 'stdev')]

library(tseries)
portfolio.optim(arc3, pm=0.07)


port_spec <- portfolio.spec(colnames(arc3))
port_spec <- add.constraint(portfolio = port_spec, type = "full_investment")
port_spec <- add.constraint(portfolio = port_spec, type = "long_only")
port_spec <- add.constraint(portfolio = port_spec, type = "return", return_target = 0.07)

port_spec <- add.objective(port_spec, type="return", name="mean")
port_spec <- add.objective(port_spec, type="risk", name="StdDev")

rp <- random_portfolios(port_spec, 100000, 'sample')
optimize.portfolio(arc3, port_spec, optimize_method='random', rp=rp)

# real opt
port_spec <- portfolio.spec(colnames(fp_ret_corr))
port_spec <- add.constraint(port_spec, type='full_investment')
port_spec <- add.constraint(port_spec, type = "long_only")
port_spec <- add.constraint(port_spec, type = "return", return_target = 0.07)
port_spec <- add.constraint(port_spec, type="position_limit", max_pos=10)

port_spec <- add.objective(port_spec, type="return", name="mean")
port_spec <- add.objective(port_spec, type="risk", name="StdDev")
#port_spec <- add.objective(port_spec, type="risk", name="StdDev", target=0.1)

rp <- random_portfolios(port_spec, 100000, 'sample')
optimize.portfolio(fp_ret_corr, port_spec, optimize_method = 'random', rp=rp)

# optimize.portfolio(fp_ret_corr, portfolio = port_spec)

```

