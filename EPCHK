*------------------------------------------------------------------------------
* <Rating>760</Rating>
*------------------------------------------------------------------------------
    SUBROUTINE EPCHK
*------------------------------------------------------------------------------
* Output file in &HOLD& where to add the results
    outf = 't24mb.csv'
* Local development prefixes array
    ldev = ''
* Record to be scanned [FILE:@ID]
*    scan = ''
    scan = 'LD.LOANS.AND.DEPOSITS':@FM:'LD1000598675'
* Checkpoint to be recorded
*    ckpt = ''
    ckpt = 'vdate'
* Sample size
    maxSampleSize = 30
*------------------------------------------------------------------------------
    $INSERT I_COMMON
    $INSERT I_EQUATE
    $INSERT I_F.STANDARD.SELECTION
    $INSERT I_F.COMPANY

    startTime = TIME()
    GOSUB INITIALISE

    selc = 'SELECT F.STANDARD.SELECTION WITH @ID UNLIKE NOFILE...'
    CALL EB.READLIST(selc, ssList, '', ssCount, '')
    FOR app_idx = 1 TO ssCount

        curApp = ssList<app_idx>
        GOSUB OPEN.APP.FILE
        IF ERR THEN CONTINUE

* Process application descriptions
        IF NOT(scan) THEN
            GOSUB GET.MEMBERSHIP
            GOSUB GET.APP.SUMMARY
        END

* Process application records
        GOSUB SELECT.APP.RECS
        IF NOT(ERR) THEN
            IF scan THEN
                GOSUB SCAN.RECS
            END ELSE
                GOSUB GET.DATA.SUMMARY
            END
        END

        CLOSE F.APP
    NEXT app_idx

    GOSUB WRITE.OUTP
    PRINT "Elapsed time: ": TIME() - startTime

    RETURN
*-------------------------------------------------------------------------------
INITIALISE:

    FN.SS = 'F.STANDARD.SELECTION'
    CALL OPF(FN.SS, F.SS)

    selc = 'SELECT F.FILE.CONTROL'
    CALL EB.READLIST(selc, fileControlList, '', fileControlCount, '')

    sels = "@ID:'|':PRODUCT"
    selc = 'SELECT F.PGM.FILE SAVING EVAL "':sels:'"'
    CALL EB.READLIST(selc, pgmFileList, '', pgmFileCount, '')
    pgmFileList = CHANGE(pgmFileList, '|', @VM)

    outp = ''

    RETURN
*-------------------------------------------------------------------------------
OPEN.APP.FILE:

    ERR = ''

* Attempt to open file
    FN.APP = 'F.':curApp
    OPEN '',FN.APP TO F.APP ELSE
        FN.APP = 'F':R.COMPANY(EB.COM.MNEMONIC):'.':curApp
        OPEN '',FN.APP TO F.APP ELSE
            ERR = 'ERR_FILE_OPEN_FAILURE'
            GOTO ERR.HANDLER
        END
    END

* Field names from SS
    fieldList = ''
    linkList = ''

    CALL F.READ(FN.SS, ssList<app_idx>, R.SS, F.SS, '')

    prevFieldNo = -1
    sysFieldCount = DCOUNT(R.SS<SSL.SYS.FIELD.NAME>, @VM)
    FOR ss_idx = 1 TO sysFieldCount

        curFieldName = R.SS<SSL.SYS.FIELD.NAME,ss_idx>

        BEGIN CASE
        CASE R.SS<SSL.SYS.FIELD.NO,ss_idx> EQ prevFieldNo
            CONTINUE
        CASE R.SS<SSL.SYS.TYPE,ss_idx> NE 'D'
            CONTINUE
        CASE FIELD(curFieldName, 'RESERVE', 2, 1)
            CONTINUE
        CASE OTHERWISE
            fieldList<-1> = curFieldName:@VM:R.SS<SSL.SYS.FIELD.NO,ss_idx>
            prevFieldNo = R.SS<SSL.SYS.FIELD.NO,ss_idx>

            relFile = R.SS<SSL.SYS.REL.FILE,ss_idx>
            IF relFile THEN
                curLink = curApp:'>':curFieldName:'|':relFile
                linkList<-1> = curLink:',type,defined'
            END ELSE
* TODO: If not data wt needed outl := ',attribute,':R.SS<SSL.SYS.FIELD.NAME,j>
            END
        END CASE
    NEXT ss_idx

    fieldCount = DCOUNT(fieldList, @FM)

    RETURN
*-------------------------------------------------------------------------------
GET.MEMBERSHIP:

* Modularization of the system
    FIND curApp IN pgmFileList SETTING fpos,vpos THEN
        curm = pgmFileList<fpos,2>
        IF NOT(curm) THEN
            curm = 'ERR_NO_PRODUCT_IN_PGM.FILE'
        END
        outp<-1> = curApp:',mbrp,':curm
    END ELSE
        ERR = 'ERR_NOT_IN_PGM.FILE'
        GOTO ERR.HANDLER
    END

* TODO: Division to core and local development

    RETURN
*-------------------------------------------------------------------------------
GET.APP.SUMMARY:

    IF linkList THEN outp<-1> = linkList
    outp<-1> = curApp:',wt_numattr,':fieldCount

    RETURN
*-------------------------------------------------------------------------------
SELECT.APP.RECS:

    ERR = ''

    FIND curApp IN fileControlList SETTING fpos THEN
        CALL EB.READLIST('SELECT ':FN.APP, recList, '', recCount, '')
    END ELSE
        ERR = 'ERR_NOT_IN_FILE.CONTROL'
        GOTO ERR.HANDLER
    END

* Sample without replacement if more than maxSampleSize records
    IF scan OR recCount LE maxSampleSize THEN
        sampleCount = recCount
        sampleList = recList
    END ELSE
        sampleCount = maxSampleSize

        rkList = ''
        FOR rec_idx = 1 TO sampleCount
            LOOP rid = RND(recCount) + 1 WHILE rid MATCHES LOWER(rkList) REPEAT
            sampleList<rec_idx> = recList<rid>
            rkList<-1> = rid
        NEXT rec_idx
    END

    RETURN
*-------------------------------------------------------------------------------
SCAN.RECS:
* TODO: Aggregate to link weights?

    FOR rec_idx = 1 TO sampleCount

        APP.ID = sampleList<rec_idx>
        CALL F.READ(FN.APP, APP.ID, R.APP, F.APP, '')
		
        R.APP = APP.ID:@FM:R.APP
        FINDSTR scan<2> IN R.APP SETTING fpos THEN
            fieldNumber = fpos - 1
            FIND fieldNumber IN fieldList SETTING fpos,vpos THEN
                curFieldName = fieldList<fpos,1>
                curLink = curApp:'>':curFieldName:'|':scan<1>:',type,scanned'
                outp<-1> = curLink:',':ckpt:',':scan<2>:' in ':APP.ID
            END ELSE
                ERR = 'ERR_FIELD_NOT_FOUND'
                GOTO ERR.HANDLER
            END
        END
    NEXT rec_idx

    RETURN
*-------------------------------------------------------------------------------
GET.DATA.SUMMARY:

    outp<-1> = curApp:',wt_numrec,':recCount

* Extract field data
    volList = '' ; fillList = ''
    FOR rec_idx = 1 TO sampleCount
        CALL F.READ(FN.APP, sampleList<rec_idx>, R.APP, F.APP, '')
        R.APP = sampleList<rec_idx>:@FM:R.APP
        FOR fld_idx = 1 TO fieldCount
            volList<fld_idx> += LEN(R.APP<fieldList<fld_idx,2>+1>)
            fillList<fld_idx> += (R.APP<fieldList<fld_idx,2>+1> NE '')
        NEXT fld_idx
    NEXT rec_idx

* TODO: volrec and voldattr seem to fit into one vol column

* Field averages
    volrec = 0 ; fillrec = 0
    FOR fld_idx = 1 TO fieldCount
        curAttr = curApp:'>':fieldList<fld_idx,1>
        IF volList<fld_idx> THEN
            volrec += volList<fld_idx>/sampleCount
            volList<fld_idx> = DROUND(volList<fld_idx>/sampleCount, 2)
        END
        outp<-1> = curAttr:',wt_volattr,':volList<fld_idx>

        IF fillList<fld_idx> THEN
            fillrec += fillList<fld_idx>/sampleCount
            fillList<fld_idx> = DROUND(fillList<fld_idx>/sampleCount, 2)
        END
        outp<-1> = curAttr:',wt_fillattr,':fillList<fld_idx>
    NEXT fld_idx

* Record averages
    outp<-1> = curApp:',wt_volrec,':DROUND(volrec, 2)
    outp<-1> = curApp:',wt_fillrec,':DROUND(fillrec, 2)

* TODO: Scan for a particular expression (contract). Can be limited to id or module

    RETURN
*-------------------------------------------------------------------------------
WRITE.OUTP:

    OPENSEQ '&HOLD&',outf TO F.OUTP ELSE
        CREATE F.OUTP THEN
            WRITESEQ 'object,property,value,checkpoint,remark' TO F.OUTP ELSE NULL
        END
    END

    outpCount = DCOUNT(outp, @FM)
    FOR i = 1 TO outpCount
        WRITESEQ outp<i> APPEND TO F.OUTP ELSE NULL
    NEXT i

    WEOFSEQ F.OUTP
    CLOSESEQ F.OUTP

    RETURN
*-------------------------------------------------------------------------------
ERR.HANDLER:

    PRINT curApp:': ':ERR
    IF NOT(scan) THEN outp<-1> = curApp:',ERROR,':ERR

    RETURN
*************************************************************************
END
